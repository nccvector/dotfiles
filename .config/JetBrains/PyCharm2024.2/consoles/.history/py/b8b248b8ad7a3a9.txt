# -*- coding: utf-8 -*-
# Copyright (C) 2014 MUJIN Inc

import os
import numpy
import time
import copy
import json
from threading import Thread, Lock
from numpy import dot, eye, zeros, float64, r_, asarray

from mujincommonsystemmanagers import ComponentStatusCode
from mujincommonsystemmanagers.commonorchestratorbase import CommonOrchestratorBase, OrchestratorCommandDecorator
from mujincommonsystemmanagers.managers import CommonManagerError
from mujincommon import basicmath, WeakMethodProxy
from mujinbinpickingmanager.managers import binpickingsettingsmanager

from mujinsensorbridgeclient.images import GetImageTypeString, MujinImageType
from mujinwebstackclient import uriutils
from mujindetection.shared.iodata import iodata

from mujincalibration import calibrationmanager, CalibrationInsufficientPatternsDetectedError
import mujincalibration.common.sceneutils as calibsceneutils
import mujincalibration.queries as calibqueries

from mujinschemaprofile_int import SchemaProfileMerger, ProfileType, GetProfileConfigurationIDPrefix, \
    GetProfileConfigurationIDSuffix, WebstackClient

from .. import ugettext as _

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import typing
    from typing import Dict, TypedDict, Tuple, Literal, List, Optional
    import numpy
    from mujincalibration.cameracalibration import CalibrateStationaryCamera
    from mujinsensorbridgeclient.sensorbridgeclient import SensorBridgeClient
    from mujinsensorbridgeclient.images import MujinImage, MujinImagePack
    from mujincommon.profileManager import FileProfileManager

    # IMPORTANT: The following are used for type checking, make sure to keep them synced with the actual schema
    # TODO(faizan): use jsonschema_types.JSONSchema when python3 is supported
    transitionStatusType = Literal['INFO', 'WARN', 'ERROR']
    stateType = Literal['IDLE', 'PLANNING', 'CAPTURING', 'COMPUTING']
    transitionInfoType = TypedDict('transitionInfoType', {
        'previousState': stateType,
        'transitionStatus': transitionStatusType,
        'success': bool,
        'statusMessage': str
    })

import logging

log = logging.getLogger(__name__)

import traceback


class CalibrationOrchestratorError(CommonManagerError):
    def __unicode__(self):
        return _('Calibration System Manager Error: %s') % self.msg


class CalibrationOrchestratorStateManager(object):
    """
    This class allows for state management, specifically for WebUI states
    during a calibration orchestration process.
    """

    _state = None  # type: Optional[stateType]
    _transitionInfo = None  # type: Optional[transitionInfoType]
    _timeStamp = None  # type: Optional[float]

    def TransitionWithError(
            self,
            nextState,  # type: stateType
            errorMessage  # type: str
    ):
        """
        Transitions to the next state with an error message.

        Args:
            nextState (stateType): The state to transition to. This should be one of: 'IDLE', 'PLANNING', 'CAPTURING', 'COMPUTING'.
            errorMessage (str): The error message to set.
        """
        self._UpdateState(nextState, False, 'ERROR', errorMessage)

    def TransitionWithWarning(
            self,
            nextState,  # type: stateType
            warningMessage  # type: str
    ):
        """
        Transitions to the next state with a warning message.

        Args:
            nextState (stateType): The state to transition to. This should be one of: 'IDLE', 'PLANNING', 'CAPTURING', 'COMPUTING'.
            warningMessage (str): The warning message to set.
        """
        self._UpdateState(nextState, True, 'WARN', warningMessage)

    def TransitionWithSuccess(
            self,
            nextState,  # type: stateType
            infoMessage  # type: str
    ):
        """
        Transitions to the next state with a success message.

        Args:
            nextState (stateType): The state to transition to. This should be one of: 'IDLE', 'PLANNING', 'CAPTURING', 'COMPUTING'.
            infoMessage (str): The success information message to set.
        """
        self._UpdateState(nextState, True, 'INFO', infoMessage)

    def _UpdateState(
            self,
            nextState,  # type: stateType
            success,  # type: bool
            transitionStatus,  # type: transitionStatusType
            statusMessage  # type: str
    ):
        """
        Updates the current state to the next state,
        along with provided success status, transition status and status message.

        Args:
            nextState (stateType): The state to transition to. This should be one of: 'IDLE', 'PLANNING', 'CAPTURING', 'COMPUTING'.
            success (bool): A boolean representing the success status.
            transitionStatus (transitionStatusType): The transition status message. This should be one of: 'INFO', 'WARN', 'ERROR'.
            statusMessage (str): The status message to set.
        """
        self._timeStamp = time.time()

        if not nextState == 'CAPTURING':
            statusMessage += "(OK to release the deadman switch)"

        self._transitionInfo = {
            'previousState': self._state,
            'transitionStatus': transitionStatus,
            'success': success,
            'statusMessage': statusMessage
        }

        self._state = nextState

    def GetFinishState(self):
        """
        Returns a dictionary representing the finished state.

        Returns:
            dict: A dictionary that contains 'finishMessage', 'finishStatus', and 'finishTime'.
        """
        return {
            'finishMessage': self.GetStatusMessage(),
            'finishStatus': self.GetTransitionStatus(),
            'finishTime': self._timeStamp,
        }

    def GetStatusMessage(self):
        """
        Returns the current status message.

        Returns:
            str: The current status message.
        """
        return self._transitionInfo['statusMessage']

    def GetState(self):
        """
        Returns the current state.

        Returns:
            stateType: The current state.
        """
        return self._state

    def CurrentStateHasError(self):
        """
        Indicates if the current state has an error.

        Returns:
            bool: True if the current state has an error, False otherwise.
        """
        return self._transitionInfo['transitionStatus'] == 'ERROR'

    def CurrentStateHasWarning(self):
        """
        Indicates if the current state has a warning.

        Returns:
            bool: True if the current state has a warning, False otherwise.
        """
        return self._transitionInfo['transitionStatus'] == 'WARN'

    def GetTransitionStatus(self):
        """
        Returns the current transition status.

        Returns:
            transitionStatusType: The current transition status.
        """
        return self._transitionInfo['transitionStatus']

    def GetPublishState(self):
        """
        Returns the current state and transition information for publishing.

        Returns:
            dict: A dictionary containing 'state' and 'transitionInfo'.
        """
        publishState = {
            'state': self._state,
            'transitionInfo': self._transitionInfo,
        }

        return publishState


class CalibrationOrchestrator(CommonOrchestratorBase):
    _systemstatusandtimestamp = None  # (ComponentStatusCode, statusmsg, lastChangedTime) for system specific loops inside this manager

    _binpickingSettingsManager = None  # type: Optional[binpickingsettingsmanager.BinpickingSettingsManager]
    _calibrationProfileManager = None  # type: Optional[FileProfileManager]

    _lockProfileSelector = None

    _cmanager = None  # CalibrationManager
    _cmanagerlock = None  # lock protecting _cmanager

    _calibrationthread = None  # the calibration thread
    _singleShotCalibrationResultCache = None  # dict with keys sensorSelectionInfo/imageType/calibrationBoardPath/sensorLinkInWorldMatrix. Where sensorLinkInWorldMatrix is the sensorLink's transform with respect to the world

    _datadir = None

    # Status manager
    _stateManager = None

    def __init__(self, **kwargs):
        super(CalibrationOrchestrator, self).__init__(**kwargs)
        assert self._managerGroup is not None
        assert self._managerGroup.settingsManager is not None

        self._cmanagerlock = Lock()
        self._sensorVolumeOfRegionSet = {}

        self._lockProfileSelector = Lock()

        self._systemstatus = (ComponentStatusCode.Communicating, _('Ready'))

        with self._lockProfileSelector:
            self._calibrationSchemaProfileMerger = SchemaProfileMerger(ProfileType.calibration)

        self._binpickingSettingsManager = binpickingsettingsmanager.BinpickingSettingsManager(
            self._managerGroup.settingsManager,
        )

        self._datadir = '/data'
        self._calibrationProfileManager = self._binpickingSettingsManager.GetCalibrationProfileManager()

        # Initialize state manager
        self._stateManager = CalibrationOrchestratorStateManager()
        self._stateManager.TransitionWithSuccess('IDLE', "Initialized calibration orchestrator")

    def __del__(self):
        self.Destroy()

    def Destroy(self):
        if self._cmanager is not None:
            self._cmanager.Destroy()
            self._cmanager = None
        self._managerGroup.settingsManager = None
        self._managerGroup.clientPoolGroup.webstackclientpool = None
        self._managerGroup.clientPoolGroup.sensorbridgeclientpool = None

        if self._binpickingSettingsManager is not None:
            self._binpickingSettingsManager.Destroy()
            self._binpickingSettingsManager = None

        super(CalibrationOrchestrator, self).Destroy()

    def HasError(self):
        return self._stateManager.CurrentStateHasError()

    @OrchestratorCommandDecorator
    def IsCalibrationRunning(self):
        return self._IsCalibrationRunning()

    def _IsCalibrationRunning(self):
        return self._stateManager.GetState() in ['PLANNING', 'CAPTURING', 'COMPUTING']

    def GetRobotName(self):
        robotname = self._orchSettingsManager.GetOrchestratorConfigValue('robotname', None)
        if robotname:
            return robotname

        robotnames = self._managerGroup.sceneModelManager.GetCachedRobotNames()
        if len(robotnames) == 1:
            return robotnames[0]

        return None

    def GetDefaultToolName(self, robotname):
        toolname = self._orchSettingsManager.GetOrchestratorConfigValue('toolname', None)
        if toolname:
            return toolname

        tools = [tool for tool in self._managerGroup.sceneModelManager.GetCachedRobotTools(robotname) if
                 tool.get('grippername')]
        if len(tools) > 0:
            # any tool should be okay since manipulator just uses it to figure out the arm dof
            return tools[0]['name']

        # if multiple tools, cannot select automatically
        return None

    @OrchestratorCommandDecorator
    def RegisterNewCalibrationCycle(self,
                                    systemState={'locationName': None, 'applicationType': "CalibrationCameraWithRobot"},
                                    timeout=2.0):
        """
        A calibration cycle is successfully registered if the pose generation succeeds for a given system state. A cycle
        contains all the necessary information to start capturing observations and later doing calibration.

        Args:
            systemState(dict): system state
            timeout: Optional timeout value in seconds (default=2.0 seconds).

        Returns:
            The log entry ID for the new calibration cycle.
        """
        # TODO: Check current state before launching thread. If another calibration is already running the CancelWork and update states accordingly before proceeding
        self._systemstatus = (ComponentStatusCode.Communicating, _('Registering new calibration cycle'))

        # Update state before starting thread
        self._stateManager.TransitionWithSuccess('PLANNING', 'Registering new calibration cycle')

        calibrationProfileId = self._GetCalibrationProfileIdFromSystemState(systemState, False)
        calibrationParameters = self._GetCalibrationParametersFromProfileId(calibrationProfileId)

        returnValue = self._RegisterNewCalibrationCycleThread(systemState['locationName'], calibrationParameters)
        log.debug("Command returning logEntryId: %s", returnValue)

        return returnValue

    @OrchestratorCommandDecorator
    def StartCaptureForCycleId(self, calibrationCycleId, timeout=2.0):
        """
        Starts thread to capture observations. CalibrationObservationPack and CalibrationObservation log entries are created for all the captures. The observations log entries keep a reference to the parent log entry which is the calibration cycle.
        Args:
            calibrationCycleId: ID of CalibrationCycle log entry
        """
        if self._IsCalibrationRunning():
            self._stateManager.TransitionWithWarning('IDLE', 'Another calibration instance is already running from QML')
        else:
            self._calibrationthread = Thread(name='calibration',
                                             target=WeakMethodProxy(self._CaptureObservationsThread),
                                             args=[calibrationCycleId])

            # The thread itself will update the states accordingly based on success/failure
            self._calibrationthread.start()

    def _CaptureObservationsThread(self, calibrationCycleId):
        self._systemstatus = (ComponentStatusCode.Communicating, _('Calibration: Capturing Observations'))
        self._stateManager.TransitionWithSuccess('CAPTURING', 'Capturing Observations')

        homePositionConfiguration = self._managerGroup.sceneModelManager.GetCachedPositionConfiguration(
            'home',
            self._orchSettingsManager.GetOrchestratorConfigValue('robotname', None)
        )

        cmanager = self._EnsureCalibrationManager()
        cmanager.ResetStatus()

        try:
            with self._managerGroup.clientPoolGroup.sensorbridgeclientpool.CreateUseScope() as sensorbridgeclient, \
                    self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient, \
                    self._managerGroup.clientPoolGroup.planningclientpool.CreateUseScope() as planningclient:

                observationPacksList, undetectedConfigIndices = cmanager.GatherObservationsForCycleId(
                    calibrationCycleId,
                    planningclient=planningclient,
                    handeyecalibclient=None,  # handeye client
                    sensorbridgeclient=sensorbridgeclient,
                    webstackclient=webstackclient,
                    homePositionConfiguration=homePositionConfiguration,
                    ignoreplanningerror=True
                )

            # Update state
            self._stateManager.TransitionWithSuccess('IDLE', 'Successfully captured observations')

        except Exception as e:
            errorMessage = traceback.format_exc()

            # Update state
            self._stateManager.TransitionWithError('IDLE', 'Error while capturing observations: ' + errorMessage)

    @OrchestratorCommandDecorator
    def StartComputeForCycleId(
            self,
            calibrationCycleId,     # type: str
            timeout=2.0,
    ):
        """
        Starts thread to capture observations. CalibrationObservationPack and CalibrationObservation log entries are created for all the captures. The observations log entries keep a reference to the parent log entry which is the calibration cycle.

        """
        if self._IsCalibrationRunning():
            self._stateManager.TransitionWithWarning('IDLE', 'Another calibration instance is already running from QML')
        else:
            self._calibrationthread = Thread(name='calibration',
                                             target=WeakMethodProxy(self._ComputeCalibrationResultsThread),
                                             args=[calibrationCycleId])

            # The thread itself will update the states accordingly based on success/failure
            self._calibrationthread.start()

    def _ComputeCalibrationResultsThread(self, calibrationCycleId):
        self._systemstatus = (ComponentStatusCode.Communicating, _('Calibration: Computing results'))
        self._stateManager.TransitionWithSuccess('COMPUTING', 'Starting to compute calibration results')

        calibrationParameters = None
        calibrationBoardParameters = None
        observationPacksList = None

        cmanager = self._EnsureCalibrationManager()
        cmanager.ResetStatus()

        logEntriesAppearanceWaitTimeInSeconds = 3.0

        try:
            with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient:

                # TODO: Put a query for this in calibqueries
                calibrationMode = webstackclient.graphApi.GetLogEntry(logEntryId=calibrationCycleId, fields={
                    "... on CalibrationCycleLogEntry": {
                        'calibrationMode': None,
                    }
                })['calibrationMode']

                calibrationParameters = calibqueries.FetchCalibrationParameters(webstackclient, calibrationCycleId)
                calibrationBoardParameters = calibqueries.FetchCalibrationBoardParameters(webstackclient,
                                                                                          calibrationCycleId)
                deserializedObservationPacksList = CalibrationOrchestrator.GetDeserializedObservationPacksListFromCycleId(
                    calibrationCycleId, webstackclient)

                intrinsicsSensorSelectionInfoList = [] if calibrationParameters[
                                                              'intrinsicsSensorSelectionInfos'] is None else \
                    calibrationParameters['intrinsicsSensorSelectionInfos']

                if len(intrinsicsSensorSelectionInfoList) > 0:
                    # WARNING: Do not pass None as an intrinsicsSensorSelectionInfoList to this function
                    # Validation of parameters should be done at the moment they are fetched from the profiles
                    # and should not be expected to be taken care of inside functions implicitly
                    self._stateManager.TransitionWithSuccess('COMPUTING', 'Performing Intrinsics Calibration')
                    cmanager.CalibrateIntrinsics(
                        calibrationCycleId,
                        deserializedObservationPacksList,
                        calibrationBoardParameters,
                        intrinsicsSensorSelectionInfoList,
                        webstackclient,
                    )
                    log.debug("Finished Intrinsics Calibration")
                    self._stateManager.TransitionWithSuccess('COMPUTING',
                                                             'Finished Intrinsics Calibration.\nWaiting for log entries to be updated in the database...')

                    # Wait for intrinsics log entries to be registered in the database
                    time.sleep(logEntriesAppearanceWaitTimeInSeconds)

                if len(calibrationParameters['extrinsicsSensorSelectionInfos']) > 1:
                    self._stateManager.TransitionWithSuccess('COMPUTING', 'Performing Relative/Stereo Calibration')
                    cmanager.CalibrateStereoCameras(
                        calibrationCycleId,
                        deserializedObservationPacksList,
                        calibrationBoardParameters,
                        calibrationParameters['primarySensorSelectionInfo'],
                        calibrationParameters['extrinsicsSensorSelectionInfos'],
                        webstackclient,
                    )
                    log.debug("Finished Relative/Stereo Calibration")

                self._stateManager.TransitionWithSuccess('COMPUTING', 'Performing Hand-Eye Calibration')
                logEntryId, calibrationResultHandEyeDict = cmanager.CalibrateHandEye(
                    calibrationCycleId,
                    deserializedObservationPacksList,
                    calibrationParameters,
                    calibrationBoardParameters,
                    webstackclient,
                    calibrationMode,
                )
                log.debug("Finished Hand-Eye Calibration")

            # Wait for log entries to be registered in the database
            time.sleep(logEntriesAppearanceWaitTimeInSeconds)

            # Update state
            self._stateManager.TransitionWithSuccess('IDLE', 'Finished computing calibration results')

        except Exception as e:
            errorMessage = traceback.format_exc()

            # Update state
            self._stateManager.TransitionWithError('IDLE', 'Error while computing calibration results: ' + errorMessage)

    @OrchestratorCommandDecorator
    def StartCaptureAndComputeForCycleId(self, calibrationCycleId, timeout=2.0):
        """
        Starts thread to capture observations. CalibrationObservationPack and CalibrationObservation log entries are created for all the captures. The observations log entries keep a reference to the parent log entry which is the calibration cycle.
        Args:
            calibrationCycleId: ID of CalibrationCycle log entry
        """
        if self._IsCalibrationRunning():
            self._stateManager.TransitionWithWarning('IDLE', 'Another calibration instance is already running from QML')
        else:
            self._calibrationthread = Thread(name='calibration', target=WeakMethodProxy(self._CaptureAndComputeThread),
                                             args=[calibrationCycleId])

            # The thread itself will update the states accordingly based on success/failure
            self._calibrationthread.start()

    def _CaptureAndComputeThread(self, calibrationCycleId):
        self._CaptureObservationsThread(calibrationCycleId)
        self._ComputeCalibrationResultsThread(calibrationCycleId)

    @OrchestratorCommandDecorator
    def HasValidCalibrationResultsFromLocation(self, locationName, applicationType):
        return self._HasValidCalibrationResultsFromLocation(locationName, applicationType)

    def _HasValidCalibrationResultsFromLocation(self, locationName, applicationType):
        latestCalibrationCycleHeader = self._GetLatestCalibrationCycleHeader(locationName)

        if latestCalibrationCycleHeader is None:
            log.error("No cycle exists for location: %s", locationName)
            return False

        latestCalibrationCycleId = latestCalibrationCycleHeader['id']
        log.debug("Checking results for latest cycle: %s", latestCalibrationCycleHeader['id'])

        hasValidCalibrationResults = False
        with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient:
            intrinsicsResultList = calibqueries.FetchCalibrationResultIntrinsicsList(webstackclient,
                                                                                     latestCalibrationCycleId)
            stereoResultList = calibqueries.FetchCalibrationResultStereoList(webstackclient, latestCalibrationCycleId)
            handeyeResult = calibqueries.FetchCalibrationResultHandEye(webstackclient, latestCalibrationCycleId)

            hasValidCalibrationResults = len(intrinsicsResultList) > 0 or len(
                stereoResultList) > 0 or handeyeResult is not None

        return hasValidCalibrationResults

    @OrchestratorCommandDecorator
    def ApplyCalibrationResultIntrinsics(self, calibrationCycleId, timeout=2.0):
        cmanager = self._EnsureCalibrationManager()
        cmanager.ResetStatus()

        with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient, \
                self._managerGroup.clientPoolGroup.sensorbridgeclientpool.CreateUseScope() as sensorbridgeclient:
            cmanager.ApplyCalibrationResultIntrinsics(calibrationCycleId, webstackclient, sensorbridgeclient)

    @OrchestratorCommandDecorator
    def ApplyCalibrationResultStereo(self, calibrationCycleId, timeout=2.0):
        """
        Applies the calibration results to the scene
        Args:
            calibrationCycleId: The log entry id of the calibration cycle.
            timeout: The timeout value for the method execution in seconds. Default value is 2.0 seconds.
        """
        cmanager = self._EnsureCalibrationManager()
        cmanager.ResetStatus()

        with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient:
            cmanager.ApplyCalibrationResultStereo(calibrationCycleId, webstackclient)

    @OrchestratorCommandDecorator
    def ApplyCalibrationResultHandEye(self, calibrationCycleId, timeout=2.0):
        """
        Applies the calibration results to the scene
        Args:
            calibrationCycleId: The log entry id of the calibration cycle.
            timeout: The timeout value for the method execution in seconds. Default value is 2.0 seconds.
        """
        cmanager = self._EnsureCalibrationManager()
        cmanager.ResetStatus()

        with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient:
            cmanager.ApplyCalibrationResultHandEye(calibrationCycleId, webstackclient)

    @staticmethod
    def GetDeserializedObservationsListForFromObservationPackId(observationPackId, webstackclient):
        """
        Retrieves observation log entries for the specified observation pack log entry ID.
        Args:
            observationPackId: ObservationPack log entry ID
            webstackclient: Webstackclient instance

        Returns:
            List of observations for the observationPack
        """
        observationsList = calibqueries.FetchCalibrationObservationsListForObservationPackId(webstackclient,
                                                                                             observationPackId)

        # Deserialize important objects
        for oIdx, observation in enumerate(observationsList):
            observation['sensorIntrinsics']['projectionMatrixKK'] = numpy.array(
                observation['sensorIntrinsics']['projectionMatrixKK'])
            observation['sensorIntrinsics']['projectionDistortionKc'] = numpy.array(
                observation['sensorIntrinsics']['projectionDistortionKc'])
            observation['matrixAttachedSensorInLink'] = numpy.array(observation['matrixAttachedSensorInLink'])

            for objectType in ['bodyInfo', 'connectedBodyInfo', 'linkInfo']:
                if observation['sensorBodyLinkInfo'].get('connectedBodyInfo'):
                    observation['sensorBodyLinkInfo'][objectType]['transformInWorld'] = numpy.array(
                        observation['sensorBodyLinkInfo'][objectType]['transformInWorld'])

                if observation['calibrationBoardBodyLinkInfo'].get('connectedBodyInfo'):
                    observation['calibrationBoardBodyLinkInfo'][objectType]['transformInWorld'] = numpy.array(
                        observation['calibrationBoardBodyLinkInfo'][objectType]['transformInWorld'])

            observation['metadata'] = iodata.LoadFromJsonString(observation['metadata'])

            # Have to do this because the above loop does not iterate over by reference
            # It was working previously, but for some reason not this step is needed to REALLY modify these keys
            observationsList[oIdx] = observation

        return observationsList

    @staticmethod
    def GetDeserializedObservationPacksListFromCycleId(calibrationCycleId, webstackclient):
        """
        Retrieves a list of observation pack log entries, also fills the observation log entries inside each observation pack.
        Args:
            calibrationCycleId: CalibrationCycle log entry ID
            webstackclient: Webstackclient instance

        Returns:
            List of observationPacks
        """
        observationPacksList = calibqueries.FetchCalibrationObservationPacksList(webstackclient, calibrationCycleId)

        # Convert matrices back to numpy arrays and also add observations list
        for packIdx, observationPack in enumerate(observationPacksList):
            observationPack['Tlink'] = numpy.array(observationPack['Tlink'])
            observationPack[
                'observations'] = CalibrationOrchestrator.GetDeserializedObservationsListForFromObservationPackId(
                observationPack['id'], webstackclient)

            # Have to do this because the above loop does not iterate over by reference
            # It was working previously, but for some reason not this step is needed to REALLY modify these two keys
            observationPacksList[packIdx] = observationPack

        return observationPacksList

    def _RegisterNewCalibrationCycleThread(self, locationName, calibrationParameters):
        self._systemstatus = (ComponentStatusCode.Communicating, _('Calibration: Registering new calibration cycle'))

        calibrationManager = self._EnsureCalibrationManager()
        calibrationManager.ResetStatus()

        try:
            logEntryId = None
            with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient, \
                    self._managerGroup.clientPoolGroup.planningclientpool.CreateUseScope() as planningclient:

                robotSpeed, robotAccel = self._managerGroup.monitorGroup.robotBridgeMonitor.GetSpeedMult()

                robotName = self.GetRobotName()
                toolName = self.GetDefaultToolName(robotName)

                logEntryId = calibrationManager.RegisterNewCalibrationCycle(
                    robotName,
                    locationName,
                    calibrationParameters,
                    {
                        'robotName': robotName,
                        'robotSpeed': robotSpeed,
                        'robotAccelerationMultiplier': robotAccel,
                        'defaultToolName': toolName,
                    },
                    planningclient=planningclient,
                    webstackclient=webstackclient
                )

            # Update state
            self._stateManager.TransitionWithSuccess('IDLE', 'Successfully registered calibration cycle')

            return logEntryId

        except Exception as e:
            errorMessage = traceback.format_exc()

            # Update state
            self._stateManager.TransitionWithError('IDLE', 'Error while registering calibration cycle: ' + errorMessage)

            return None

    def _CreateCalibrationManager(self):
        if not self._managerGroup.settingsManager.IsSceneConfigured():
            return None

        calibmanager = calibrationmanager.CalibrationManager(
            scenepk=uriutils.GetPrimaryKeyFromURI(
                self._managerGroup.settingsManager.GetUserConfigValue('sceneuri', '')),
            calibrationdatadir=os.path.join(self._datadir, 'calibration'),
        )
        return calibmanager

    def _EnsureCalibrationManager(self):
        """Initialize and return the calibration manager
        """
        with self._cmanagerlock:
            if self._cmanager is None:
                self._cmanager = self._CreateCalibrationManager()
            return self._cmanager

    def _GetCalibrationManager(self):
        """Get and return the calibration manager if there is one initialized, otherwise returns None
        """
        with self._cmanagerlock:
            return self._cmanager

    def ResetError(self):
        self._systemstatus = (ComponentStatusCode.Communicating, _('Ready'))

        self._stateManager.TransitionWithSuccess("IDLE", "Reset error")

        cmanager = self._GetCalibrationManager()
        if cmanager is not None:
            cmanager.ResetStatus()

    def _EnsureCalibrationParametersFromSystemState(self, systemState):
        """Creates a new profile entry and returns its profileId

        Args:
            systemState: dict of state values as specified in profileMapSchema.profileSelectorProperties

        """
        profileIds = self._calibrationProfileManager.GetProfileIds()

        if 'profileId' in systemState:
            if systemState['profileId'] in profileIds:
                return systemState['profileId']  # already there

        else:
            systemState = copy.copy(systemState)
            if systemState:
                sortedSystemStates = sorted(list(systemState.items()))
                baseProfileId = '_'.join([value for name, value in sortedSystemStates])
            else:
                baseProfileId = 'default'

            systemState['profileId'] = baseProfileId
            if systemState['profileId'] in profileIds:
                index = 1
                while True:
                    newProfileId = '%s_%d' % (baseProfileId, index)
                    if newProfileId not in profileIds:
                        systemState['profileId'] = newProfileId
                        break
                    index += 1

        self._calibrationProfileManager.AddProfilesMapEntry(systemState, True)
        if 'profileId' in systemState and systemState['profileId'] not in profileIds:
            self._calibrationProfileManager.SetProfile(systemState['profileId'],
                                                       {})  # create an empty calibration profile since it doesn't exist.
        return systemState['profileId']

    def _GetCalibrationProfileIdFromSystemState(self, systemState, exactMatch, timeout=5):
        """Returns the set calibration parameters using the current system state. If none exist, then returns empty dict.

        Assumes _lockProfileSelector is locked
        """
        # don't put lock, the caller should already add lock
        profileId = None
        self._calibrationSchemaProfileMerger.SyncProfileSelector(WebstackClient(self._managerGroup.settingsManager.GetControllerConfig())) # create the client on the spot, not very efficient, but okay for now
        profileId = self._calibrationProfileManager.FindBaseProfileId(systemState, exactMatch, self._calibrationSchemaProfileMerger.schemaMerger.selectionOrder)

        if profileId is None:
            log.info('calibration profile for systemState=%r does not exist in mapping.', systemState)
            profileId = self._EnsureCalibrationParametersFromSystemState(systemState)

        return profileId

    @OrchestratorCommandDecorator
    def GetLocationNameFromProfileId(self, calibrationProfileId):
        return self._GetLocationNameFromProfileId(calibrationProfileId)

    def _GetLocationNameFromProfileId(self, calibrationProfileId):
        profileSelectionRules = self._calibrationProfileManager.GetProfilesMapValue().get('baseProfileSelectionRules', [])

        locationName = None
        for rule in profileSelectionRules:
            if rule['profileId'] == calibrationProfileId:
                locationName = rule.get('locationName', None)

        log.debug("Returning location name (%s) for profileId (%s)", locationName, calibrationProfileId)
        return locationName

    def CancelCalibration(self, reason):
        """ Cancel any currently running calibration (block until stopped)
        """
        log.info(u'Trying to cancel calibration')
        cmanager = self._EnsureCalibrationManager()
        if cmanager is not None:
            cmanager.Cancel(reason)
        if self._calibrationthread is not None:
            self._calibrationthread.join()
            self._calibrationthread = None
            # wait for the calibration thread to finish
            # destroy the calibration thread

    def _GetCalibrationParametersFromProfileId(self, calibrationProfileId):
        # type: (str) -> dict   # TODO(faizan): Add calibrationParametersType when python3 is supported

        assert (calibrationProfileId)

        with self._lockProfileSelector:
            try:
                self._calibrationSchemaProfileMerger.SyncProfileSelector(WebstackClient(self._managerGroup.settingsManager.GetControllerConfig())) # create the client on the spot, not very efficient, but okay for now
                calibrationParameters = self._calibrationProfileManager.GetProfileValue(calibrationProfileId)
                return self._calibrationSchemaProfileMerger.AddMissingDefaultValuesToParameters(
                    {},     # System state in case of dynamic default. But for calibration we do not have dynamic defaults
                    [],
                    {},
                    calibrationParameters,
                )

            except Exception as e:
                log.error('Could not get calibrationParameters from profileId=%r: %s', calibrationProfileId, e)
                return {'id': '%s%s%s' % (
                    GetProfileConfigurationIDPrefix(ProfileType.calibration), calibrationProfileId,
                    GetProfileConfigurationIDSuffix(ProfileType.calibration))}

    @OrchestratorCommandDecorator
    def GetCalibrationParametersFromProfileId(self, calibrationProfileId, timeout=5):
        return self._GetCalibrationParametersFromProfileId(calibrationProfileId)

    @OrchestratorCommandDecorator
    def CancelAll(self, reason):
        if self._stateManager.GetState() != "IDLE":
            self._stateManager.TransitionWithWarning("IDLE", "CancelAll: " + reason)
            try:
                self.CancelCalibration(reason)
                self._managerGroup.warningMessageManager.DeleteWarningMessage(context='CancelAll.CancelCalibration')
            except Exception as e:
                self._managerGroup.warningMessageManager.AddAndLogWarningMessage(_('Failed to stop calibration.'),
                                                                                 'System',
                                                                                 context='CancelAll.CancelCalibration',
                                                                                 exception=e)

        if self._calibrationthread is not None:
            self._calibrationthread.join()
            self._calibrationthread = None

    @OrchestratorCommandDecorator
    def CancelWork(self, *args, **kwargs):
        return self.CancelAll(*args, **kwargs)

    @OrchestratorCommandDecorator
    def SaveCalibrationConfiguration(self, calibrationProfileId, calibrationParameters):
        return self._calibrationProfileManager.SetProfile(calibrationProfileId,
                                                          calibrationParameters)  # same as save profile

    def _GetCalibrationParametersFromSystemState(self, systemState, exactMatch=False, timeout=5):
        with self._lockProfileSelector:
            calibrationProfileId = self._GetCalibrationProfileIdFromSystemState(systemState, exactMatch)
            assert (calibrationProfileId)
            try:
                calibrationParameters = self._calibrationProfileManager.GetProfileValue(calibrationProfileId)
                if calibrationParameters:
                    return calibrationProfileId, calibrationParameters
            except Exception as e:
                log.error('Could not get calibrationParameters from profileId=%r: %s', calibrationProfileId, e)

            calibrationParameters = {'id': '%s%s%s' % (
                GetProfileConfigurationIDPrefix(ProfileType.calibration), calibrationProfileId,
                GetProfileConfigurationIDSuffix(ProfileType.calibration))}
            return calibrationProfileId, calibrationParameters

    @OrchestratorCommandDecorator
    def GetCalibrationParametersFromSystemState(self, *args, **kwargs):
        return self._GetCalibrationParametersFromSystemState(*args, **kwargs)

    def _GetCachedSingleShotSensorLinkInWorldMatrix(self, sensorSelectionInfo):
        """Returns the cached sensorLinkInWorldMatrix computed from ComputeSingleShotCalibrationWithLiveImage

        Returns:
            currentSensorLinkInWorldMatrix (ndarray): the current scene sensor link transform in the world
            detectedSensorLinkInWorldMatrix (ndarray): the detected sensor link transform in the world
        """
        if self._singleShotCalibrationResultCache is not None:
            if self._singleShotCalibrationResultCache['sensorSelectionInfo'] == sensorSelectionInfo:
                return self._singleShotCalibrationResultCache.get(
                    'currentSensorLinkInWorldMatrix'), self._singleShotCalibrationResultCache.get(
                    'detectedSensorLinkInWorldMatrix')

        return None, None

    @OrchestratorCommandDecorator
    def GetCachedSingleShotSensorLinkInWorldMatrix(self, *args, **kwargs):
        return self._GetCachedSingleShotSensorLinkInWorldMatrix(*args, **kwargs)

    # TODO (Ali): headers need a schema of their own
    @OrchestratorCommandDecorator
    def GetSortedCalibrationCycleHeaders(self, filterLocationName=None):
        sortedCalibrationCycleHeaders = []
        with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient:
            sortedCalibrationCycleHeaders = calibqueries.FetchCalibrationCycleHeaders(webstackclient,
                                                                                      filterLocationName)

        return sortedCalibrationCycleHeaders

    @OrchestratorCommandDecorator
    def GetLatestCalibrationCycleHeader(self, filterLocationName=None):
        return self._GetLatestCalibrationCycleHeader(filterLocationName)

    def _GetLatestCalibrationCycleHeader(self, filterLocationName=None):
        latestCalibrationCycleHeader = None
        with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient:
            sortedResults = calibqueries.FetchCalibrationCycleHeaders(webstackclient, filterLocationName)
            if len(sortedResults) > 0:
                latestCalibrationCycleHeader = sortedResults[-1]

        return latestCalibrationCycleHeader

    @OrchestratorCommandDecorator
    def GetCalibrationResultHandEyeForCycleId(self, calibrationCycleId):
        with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient:
            return calibqueries.FetchCalibrationResultHandEye(webstackclient, calibrationCycleId)

    def _StartQMLCalibrationCameraWithRobot(self, calibrationProfileId, useSavedObservations):
        """starts the calibration in a separate thread (non-blocking)
        Args:
            calibrationProfileId (str): the id of the calibration to start
        """
        log.info('Starting calibration of calibrationProfileId=%r', calibrationProfileId)
        self.CancelAll(_('Cancel due to starting new calibration.'))
        self._calibrationthread = Thread(name='calibration', target=WeakMethodProxy(self._RunQMLCalibrationThread),
                                         args=[calibrationProfileId, useSavedObservations])
        self._calibrationthread.start()

    def _GetCalibrationBoardPaths(self):
        currentScene = self._managerGroup.sceneModelManager.GetCachedScene()
        if not currentScene:
            log.info('current scene is not cached')
            return []

        return [u'/'.join(parts) for parts in
                calibsceneutils.ExtractCalibrationBoardPathPartsFromSceneObjects(currentScene.instobjects,
                                                                                 self._managerGroup.sceneModelManager)]

    @OrchestratorCommandDecorator
    def GetCalibrationBoardPaths(self):
        return self._GetCalibrationBoardPaths()

    def _ApplySingleShotCalibration(self, sensorSelectionInfo):
        """applies the detectedSensorLinkInWorldMatrix to the scene

        Returns:
            bool: True if applied
        """
        detectedSensorLinkInWorldMatrix = self.GetCachedSingleShotSensorLinkInWorldMatrix(sensorSelectionInfo)[1]
        if detectedSensorLinkInWorldMatrix is not None:
            cmanager = self._EnsureCalibrationManager()
            if cmanager is not None:
                with self._managerGroup.clientPoolGroup.planningclientpool.CreateUseScope() as planningclient, \
                        self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient:
                    planningclient.SetRobotName(self.GetRobotName())
                    return cmanager.UpdateControllerWithNewSensorLinkPose(
                        sensorSelectionInfo,
                        detectedSensorLinkInWorldMatrix,
                        webstackclient,
                        planningclient
                    )

        return False

    @OrchestratorCommandDecorator
    def ApplySingleShotCalibration(self, *args, **kwargs):
        return self._ApplySingleShotCalibration(*args, **kwargs)

    @OrchestratorCommandDecorator
    def GetDefaultCalibrationParameters(self):
        log.error('GetDefaultCalibrationParmeters not implemented')
        return None

    # TODO: SHOULD LIVE IN CALIBRATION UTILS
    def GetCalibrationBoardParameters(self, calibrationBoardPath, timeout=3.0):
        """Get calibration board parameters
        """
        currentScene = self._managerGroup.sceneModelManager.GetCachedScene()
        if currentScene is None:
            log.debug('no cached scene')
            return None

        calibrationBoardPaths = self.GetCalibrationBoardPaths()
        if calibrationBoardPath not in calibrationBoardPaths:
            log.debug('calibrationBoardPath "%s" not in %r', calibrationBoardPath, calibrationBoardPaths)
            return None

        calibrationBoardPathParts = calibrationmanager.ParseCalibrationBoardPath(calibrationBoardPath)
        scenepk = uriutils.GetPrimaryKeyFromURI(self._managerGroup.settingsManager.GetUserConfigValue('sceneuri', ''))

        calibboardParameters = None
        with self._managerGroup.clientPoolGroup.webstackclientpool.CreateUseScope() as webstackclient:
            calibboardParameters = calibsceneutils.ExtractCalibrationBoardParametersFromPathParts(scenepk,
                                                                                                  calibrationBoardPathParts,
                                                                                                  webstackclient)

        return calibboardParameters

    def _GetStationaryCameraCalibratorFromCalibrationBoard(self, calibrationBoardPath):
        calibrationBoardParameters = self.GetCalibrationBoardParameters(calibrationBoardPath)
        if calibrationBoardParameters is None:
            log.warn(u'Can not get calibrationBoardParameters for calibrationBoardPath "%s"', calibrationBoardPath)
            return None

        cmanager = self._EnsureCalibrationManager()
        return cmanager.CreateCameraCalibration(calibrationBoardParameters)

    def _GetCalibrationBoardDotsInImage(self, objectPoints, boardInWorldMatrix, sensorLinkInWorldMatrix, KK, Kc):
        """Returns (K,2) matrix of image dots
        """
        from mujinvisioncommon import camerafuncs
        objectPointsInWorld = basicmath.TransformPoints(boardInWorldMatrix, objectPoints)
        objectPointsInSensorFrame = basicmath.TransformPoints(basicmath.InvertIsometricMatrix(sensorLinkInWorldMatrix),
                                                              objectPointsInWorld)
        return camerafuncs.ProjectPoints(objectPointsInSensorFrame, KK, Kc)

    def _GetCalibrationBoardAxesInImage(self, cameracal, boardInWorldMatrix, sensorInWorldMatrix, KK, Kc):
        """Computes the calibration board origin in the image

        Args:
            boardInWorldMatrix (ndarray): the board transform with respect to the world.
            sensorInWorldMatrix (ndarray): the sensor transform with respect to the world.
        """
        from mujinvisioncommon import camerafuncs
        boardInSensorMatrix = dot(basicmath.InvertIsometricMatrix(sensorInWorldMatrix), boardInWorldMatrix)
        axisLength = cameracal.pattern['spacing_x'] * cameracal.pattern['corners_x']
        poseAxesPoints = numpy.array([
            [0, 0, 0], [axisLength, 0, 0],
            [0, 0, 0], [0, axisLength, 0],
            [0, 0, 0], [0, 0, axisLength],
        ])
        return camerafuncs.ProjectPoints(basicmath.TransformPoints(boardInSensorMatrix, poseAxesPoints), KK,
                                         Kc).reshape(3, 4)

    def _ComputeSensorPoseFromPatternDetection(self, cameracal, boardInWorldMatrix, imagedata, KK, Kc, timeout=1.0):
        # type: (CalibrateStationaryCamera, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, float) -> Tuple[Optional[list[float]], Optional[numpy.ndarray]]
        """Given the calibration board in the world, detect calibration board with another camera and compute its pose in the world

        Args:
            boardInWorldMatrix (ndarray): 4x4 matrix of the transform the calibration board in the world.

        Returns:
            detectedPatternDots (ndarray): If detected the corner coordinates in the image space
            sensorInWorldMatrix (ndarray): If detected, the 4x4 matrix of the sensor in the world coordinate system
        """
        try:
            detectedPatternDots = cameracal.DetectNewPattern(numpy.squeeze(imagedata))
        except Exception as e:
            log.error(e)
            return None, None

        if detectedPatternDots is None:
            log.error('Could not detect any calibration board pattern.')
            return None, None

        objectPoints = cameracal.GetObjectPoints()

        # there could be Nones, so filter
        validDetectedPoints = zeros((0, 2), float64)
        validObjectPoints = zeros((0, 3), float64)
        for detectedPoint, objectPoint in zip(detectedPatternDots, objectPoints):
            if detectedPoint is not None:
                validDetectedPoints = r_[validDetectedPoints, [detectedPoint]]
                validObjectPoints = r_[validObjectPoints, [objectPoint]]

        from mujincalibration.cameracalibration import CalibrateStationaryCamera
        boardInSensorMatrix = CalibrateStationaryCamera.ComputePatternMatrixUsing2DCorners(validDetectedPoints,
                                                                                           validObjectPoints, KK, Kc)
        sensorInWorldMatrix = numpy.dot(boardInWorldMatrix, basicmath.InvertIsometricMatrix(boardInSensorMatrix))
        return detectedPatternDots, sensorInWorldMatrix

    def _ComputeBoardPoseInSensorFrameFromPointCloud(
            self,
            cameracal,  # type: CalibrateStationaryCamera
            imagedata,  # type: numpy.ndarray
            Kk,  # type: numpy.ndarray
            Kc,  # type: numpy.ndarray
            points,  # type: numpy.ndarray
            pointCloudFittingParameters,  # type: dict
    ):  # type: (...) -> Tuple[Optional[numpy.ndarray], Optional[numpy.ndarray], Optional[numpy.ndarray], Optional[numpy.ndarray]]
        Kk, Kc = asarray(Kk), asarray(Kc)
        sensorInWorldPose = basicmath.ConvertPoseFromMatrix(numpy.eye(4))
        primaryObservations = {"data": [{"image_raw": imagedata, "image_rect": imagedata, "Tlink": numpy.eye(4),
                                         "sensorInWorldPose": sensorInWorldPose}], 'sensorSelectionInfo': None}
        objectPoints = cameracal.GetObjectPoints()
        primaryResults, primary_all_optimization_data, primary_corners_detected_indices = cameracal.Detect2DCornersIn2DObservations(
            primaryObservations, {"KK": Kk, "kc": Kc}, objectPoints=objectPoints)
        if not primaryResults:
            return None, None, None, None

        depthSensorInWorldPose = [1.0, 0, 0, 0, 0, 0, 0]  # for now assume same as image
        secondaryObservations = {"data": [{"image_raw": points, "sensorInWorldPose": depthSensorInWorldPose}],
                                 "imageType": "DepthXYZ"}
        triangulated_all_optimization_data, triangulated_corners_detected_indices = cameracal.Process2DCornersAndDepthFor3DCorners(
            primaryObservations, None, primaryResults, secondaryObservations, None, objectPoints,
            pointCloudFittingParameters)
        if len(triangulated_all_optimization_data) == 0:
            log.warn('Could not find the calib board from the 2D image.')
            # although can return a pose from 2D, it won't be accurate, so best not confuse the user
            # boardInSensorMatrix = CalibrateStationaryCamera.ComputePatternMatrixUsing2DCorners(corners=primary_all_optimization_data[0], object_points=detectedPatternDotsObjectPoints, KK=Kk, kc=Kc)
            return None, None, None, None

        detectedPatternDots2DStructured = primaryResults[0]["corners_detected"]
        detectedPatternDots3D = triangulated_all_optimization_data[0][0]
        detectedPatternDotsObjectPoints = triangulated_all_optimization_data[0][1]

        cornerMask = zeros(len(objectPoints), bool)
        for detectedPatternDotsObjectPoint in detectedPatternDotsObjectPoints:
            cornerMask[numpy.argmin(numpy.linalg.norm(objectPoints - detectedPatternDotsObjectPoint, axis=1))] = True
        cornerMask = asarray(cornerMask)
        detectedPatternDots2D = asarray(detectedPatternDots2DStructured)[cornerMask]

        from mujincalibration.cameracalibration import CalibrateStationaryCamera
        boardInSensorMatrix = CalibrateStationaryCamera.ComputeRigidTransformFrom3DPointCorrespondences(
            detectedPatternDots3D, detectedPatternDotsObjectPoints)

        return detectedPatternDots2D, detectedPatternDots3D, boardInSensorMatrix, cornerMask

    def _ComputeBoardPoseFromPointCloud(
            self,
            cameracal,  # type: CalibrateStationaryCamera
            sensorInWorldMatrix,  # type: numpy.ndarray
            imagedata,  # type: numpy.ndarray
            Kk,  # type: numpy.ndarray
            Kc,  # type: numpy.ndarray
            points,  # type: numpy.ndarray
            pointCloudFittingParameters,  # type: dict
            timeout=1.0,  # type: float
    ):  # type: (...) -> Tuple[Optional[numpy.ndarray], Optional[numpy.ndarray]]
        """Given the camera in the world, detect the calibration board in its frame, and return the board pose in the world.

        Args:
            sensorInWorldMatrix (ndarray): 4x4 matrix of the transform  of the sensor in the world.
            points (ndarray): HxWx3 structured point data

        Returns:
            detectedPatternDots2D (ndarray): If detected the corner coordinates in the image space
            boardInWorldMatrix (ndarray): If detected, the 4x4 matrix of the sensor in the world coordinate system
        """
        detectedPatternDots2D, detectedPatternDots3D, boardInSensorMatrix, cornerMask = self._ComputeBoardPoseInSensorFrameFromPointCloud(
            cameracal, imagedata, Kk, Kc, points, pointCloudFittingParameters)
        if boardInSensorMatrix is None:
            return None, None

        boardInWorldMatrix = dot(sensorInWorldMatrix, boardInSensorMatrix)
        return detectedPatternDots2D, boardInWorldMatrix

    def _ComputeBoardPoseFromPatternDetection(
            self,
            cameracal,  # type: CalibrateStationaryCamera
            sensorInWorldMatrix,  # type: numpy.ndarray
            imagedata,  # type: numpy.ndarray
            KK,  # type: numpy.ndarray
            Kc,  # type: numpy.ndarray
            timeout=1.0,  # type: float
    ):  # type: (...) -> Tuple[Optional[numpy.ndarray], Optional[numpy.ndarray]]
        """Given the camera in the world, detect the calibration board in its frame, and return the board pose in the world.

        Args:
            sensorInWorldMatrix (ndarray): 4x4 matrix of the transform  of the sensor in the world.

        Returns:
            detectedPatternDots (ndarray): If detected the corner coordinates in the image space
            boardInWorldMatrix (ndarray): If detected, the 4x4 matrix of the sensor in the world coordinate system
        """
        try:
            detectedPatternDots = cameracal.DetectNewPattern(imagedata)
        except Exception as e:
            log.error(e)
            return None, None

        if detectedPatternDots is None:
            log.error('Could not detect any calibration board pattern.')
            return None, None

        objectPoints = cameracal.GetObjectPoints()

        # there could be Nones, so filter
        validDetectedPoints = zeros((0, 2), float64)
        validObjectPoints = zeros((0, 3), float64)
        for detectedPoint, objectPoint in zip(detectedPatternDots, objectPoints):
            if detectedPoint is not None:
                validDetectedPoints = r_[validDetectedPoints, [detectedPoint]]
                validObjectPoints = r_[validObjectPoints, [objectPoint]]

        from mujincalibration.cameracalibration import CalibrateStationaryCamera
        boardInSensorMatrix = CalibrateStationaryCamera.ComputePatternMatrixUsing2DCorners(validDetectedPoints,
                                                                                           validObjectPoints, KK, Kc)
        boardInWorldMatrix = numpy.dot(sensorInWorldMatrix, boardInSensorMatrix)
        return detectedPatternDots, boardInWorldMatrix

    def GetCalibrationBoardTransform(self, calibrationBoardPath, timeout=3.0):
        """Get calibration board transform in the world

        :param calibrationBoardPath: calibration board name, see naming convention in GetCalibrationBoardPaths()
        :return:
            * if not valid calibration board path, returns empty list
            * it valid calibration board path, but cannot find calibration board in slave, then returns empty list
            * otherwise, returns global transform of calibration board in following format: [quat0, quat1, quat2, quat3, translationX, translationY, translationZ]
        """
        calibrationBoardPathParts = calibrationmanager.ParseCalibrationBoardPath(calibrationBoardPath)
        with self._managerGroup.clientPoolGroup.planningclientpool.CreateUseScope() as planningclient:
            planningclient.SetRobotName(self.GetRobotName())
            transform = planningclient.GetTransform(targetname=calibrationBoardPathParts[0],
                                                    linkName=calibrationBoardPathParts[1],
                                                    geometryName=calibrationBoardPathParts[2])
        return basicmath.matrixFromPose(transform['quaternion'] + transform['translation'])

    def _ComputeSingleShotCalibrationWithLiveImage(
            self,
            sensorName,  # type: str
            sensorLinkName,  # type: str
            requestedImageTypes,  # type: List[str]
            calibrationProfileId,  # type: str
            runDetection=True,  # type: bool
            extraOptions=None,  # type: Optional[Dict]
    ):  # type: (...) -> Tuple[Optional[MujinImage], Optional[numpy.ndarray], Optional[MujinImage], Optional[numpy.ndarray], Optional[numpy.ndarray], Optional[numpy.ndarray]]
        """
        Args:
            requestedImageTypes (list): list of requested image types, might not all be available
        """
        calibrationParameters = self.GetCalibrationParametersFromProfileId(calibrationProfileId)

        # have to add depth images
        # TODO: use sensorbridge client decorator scope
        with self._managerGroup.clientPoolGroup.sensorbridgeclientpool.CreateUseScope() as sensorbridge:
            sensorbridge = typing.cast(SensorBridgeClient, sensorbridge)
            supportedImageTypes = sensorbridge.GetSupportedImageTypes(sensorName, sensorLinkName)
            for imageType in requestedImageTypes:
                if GetImageTypeString(imageType) not in supportedImageTypes:
                    log.warn(u'Sensors "%s/%s" does not support imageType "%s"', sensorName, sensorLinkName, imageType)
                    return (None, None, None, None, None, None)

            imageTypes = list(requestedImageTypes)
            acceptable3DImageTypes = [MujinImageType.Disparity, MujinImageType.DepthXYZ, MujinImageType.Depth]
            capturePointCloud = calibrationmanager.ShouldCapturePointCloud(calibrationParameters)
            if capturePointCloud:
                # see which image types are supported
                for imageType in acceptable3DImageTypes:
                    if GetImageTypeString(imageType) in supportedImageTypes:
                        imageTypes.append(imageType)
                        break

            log.debug('capturing with imageTypes=%r, capturePointCloud=%r, calibrationParameters=%r', imageTypes,
                      capturePointCloud, calibrationParameters)
            imagePack = sensorbridge.SnapImages(
                [
                    {
                        'sensorName': sensorName,
                        'sensorLinkName': sensorLinkName,
                        'imageTypes': map(GetImageTypeString, imageTypes),
                    }
                ],
                usecache=False,
                systemState={
                    'applicationType': 'calibrationCameraSingleShot',
                    'sensorName': sensorName,
                    'sensorLinkName': sensorName,
                },
                extraoptions=extraOptions,
            )  # type: MujinImagePack
            images = imagePack.images

        if images is None:
            return (None, None, None, None, None, None)

        intensityImage = None
        depthImage = None
        for image in images:
            if image.GetImageType() in acceptable3DImageTypes:
                depthImage = image
            else:
                intensityImage = image
        if intensityImage is None:
            return (None, None, None, None, None, None)

        intensityImageData = intensityImage.npimage if intensityImage is not None else None
        if not calibrationParameters or not calibrationParameters.get('calibrationBoardSource') or not \
                calibrationParameters['calibrationBoardSource'].get('calibrationBoardPath'):
            log.verbose('invalid calibrationParameters=%r from calibrationProfileId=%r', calibrationParameters,
                        calibrationProfileId)
            return (intensityImage, intensityImageData, None, None, None, None)

        calibrationBoardSource = calibrationParameters['calibrationBoardSource']
        calibrationBoardPath = calibrationBoardSource.get('calibrationBoardPath')
        cameracal = self._GetStationaryCameraCalibratorFromCalibrationBoard(calibrationBoardPath)
        if cameracal is None:
            return (intensityImage, intensityImageData, None, None, None, None)

        # override minimum detections to be 1, default is 4
        cameracal.minNumDetectedPatterns = 1

        pointCloudFittingParameters = None
        if calibrationParameters.get("extrinsicsCalibration"):
            pointCloudFittingParameters = calibrationParameters.get("extrinsicsCalibration").get("pointCloudFitting")
        boardInWorldMatrix = None
        patternDotsInWorld = None
        currentPoseAxesInImage = None
        if calibrationBoardSource.get('calibrationBoardSourceType') == 'sensor':
            if calibrationBoardSource.get('sensorName') and calibrationBoardSource.get('sensorLinkName'):
                # take a snapshot of the other sensor
                # TODO: use sensorbridge client decorator scope
                with self._managerGroup.clientPoolGroup.sensorbridgeclientpool.CreateUseScope() as sensorbridge:
                    refSupportedImageTypes = sensorbridge.GetSupportedImageTypes(
                        calibrationBoardSource.get('sensorName'), calibrationBoardSource.get('sensorLinkName'))

                    imageTypes = []
                    for imageType in requestedImageTypes:
                        if GetImageTypeString(imageType) in refSupportedImageTypes:
                            imageTypes.append(imageType)
                    if len(imageTypes) == 0:
                        # could not find the requested one, so pick and IR/Color
                        acceptable2DImageTypes = [MujinImageType.IR, MujinImageType.Color]
                        for imageType in acceptable3DImageTypes:
                            if GetImageTypeString(imageType) in refSupportedImageTypes:
                                imageTypes.append(imageType)
                                break

                    acceptable3DImageTypes = [MujinImageType.Disparity, MujinImageType.Depth, MujinImageType.DepthXYZ]
                    if capturePointCloud:
                        # see which image types are supported
                        for imageType in acceptable3DImageTypes:
                            if GetImageTypeString(imageType) in refSupportedImageTypes:
                                imageTypes.append(imageType)
                                break

                    if len(imageTypes) == 0:
                        # have no images to capture
                        return (intensityImage, intensityImageData, None, None, None, None)

                    sourceImagePack = sensorbridge.SnapImages(
                        [{'sensorName': calibrationBoardSource.get('sensorName'),
                          'sensorLinkName': calibrationBoardSource.get('sensorLinkName'),
                          'imageTypes': map(GetImageTypeString, imageTypes)}],
                        usecache=False, systemState={'applicationType': 'calibrationCameraSingleShot',
                                                     'sensorName': calibrationBoardSource.get('sensorName'),
                                                     'sensorLinkName': calibrationBoardSource.get('sensorLinkName')},
                        extraoptions=extraOptions)
                    if len(sourceImagePack.images) > 0:
                        sourceIntensityImage = None
                        sourceDepthImage = None
                        for image in sourceImagePack.images:
                            if image.GetImageType() in acceptable3DImageTypes:
                                sourceDepthImage = image
                            else:
                                sourceIntensityImage = image

                        try:
                            if sourceIntensityImage is not None:
                                sourceMetadata = json.loads(sourceIntensityImage.metadata)
                                if not sourceMetadata:
                                    log.warn(u'intensity image "%s" does have any metadata %r',
                                             sourceIntensityImage.GetImageType(), sourceIntensityImage.metadata)
                                else:
                                    KK = numpy.asarray(sourceMetadata['KK'])
                                    kc = numpy.asarray(sourceMetadata['distortion'])
                                    if capturePointCloud and sourceDepthImage is not None:
                                        depthMetadata = json.loads(sourceDepthImage.metadata)
                                        structuredPointsInDepth = None
                                        if sourceDepthImage.GetImageType() == MujinImageType.Disparity:
                                            import mujinvisioncommonutilitiesbindings
                                            structuredPointsInDepth = mujinvisioncommonutilitiesbindings.ConvertDisparityToDepthXYZ(
                                                depthMetadata['reprojection'], sourceDepthImage.npimage)
                                        elif sourceDepthImage.GetImageType() == MujinImageType.Depth:
                                            import mujinvisioncommonutilitiesbindings
                                            structuredPointsInDepth = mujinvisioncommonutilitiesbindings.ConvertDepthMapToDepthXYZ(
                                                depthMetadata['KK'], sourceDepthImage.npimage)
                                        elif sourceDepthImage.GetImageType() == MujinImageType.DepthXYZ:
                                            structuredPointsInDepth = sourceDepthImage.npimage
                                        else:
                                            # unsupported
                                            pass

                                        if structuredPointsInDepth is not None:
                                            patternDotsInSourceImage, boardInWorldMatrix = self._ComputeBoardPoseFromPointCloud(
                                                cameracal,
                                                basicmath.matrixFromPose(sourceMetadata['sensorInWorldPose']),
                                                sourceIntensityImage.npimage,
                                                KK,
                                                kc,
                                                structuredPointsInDepth,
                                                pointCloudFittingParameters,

                                            )
                                        else:
                                            log.warn('could not extract point cloud from image "%s"',
                                                     sourceDepthImage.GetImageType())
                                    else:
                                        patternDotsInSourceImage, boardInWorldMatrix = self._ComputeBoardPoseFromPatternDetection(
                                            cameracal,
                                            basicmath.matrixFromPose(sourceMetadata['sensorInWorldPose']),
                                            sourceIntensityImage.npimage,
                                            KK,
                                            kc)
                                    log.debug(
                                        'Computed calibration board from reference source camera sensorName "%s", sensorLinkName "%s", imageType "%s", sensorInWorldPose=%r',
                                        sourceIntensityImage.GetSensorName(), sourceIntensityImage.GetSensorLinkName(),
                                        sourceIntensityImage.GetImageType(), sourceMetadata['sensorInWorldPose'])
                        except CalibrationInsufficientPatternsDetectedError as e:
                            log.warn(u'Failed to detect calibration pattern from sensor "%s/%s": %s',
                                     calibrationBoardSource.get('sensorName'),
                                     calibrationBoardSource.get('sensorLinkName'), e)
                    else:
                        log.warn('Could not get images for refererence source camera "%s/%s"',
                                 calibrationBoardSource.get('sensorName'), calibrationBoardSource.get('sensorLinkName'))
        else:
            boardInWorldMatrix = self.GetCalibrationBoardTransform(calibrationBoardPath)  # from the scene

        if boardInWorldMatrix is None:
            return (intensityImage, intensityImageData, None, None, None, None)

        metadata = json.loads(intensityImage.metadata)
        KK = numpy.asarray(metadata['KK'])
        Kc = numpy.asarray(metadata['distortion'])
        sensorInWorldMatrix = basicmath.matrixFromPose(metadata['sensorInWorldPose'])  # from the scene

        # Data for visualization for this image
        currentPatternDotsInImage = self._GetCalibrationBoardDotsInImage(cameracal.GetObjectPoints(),
                                                                         boardInWorldMatrix, sensorInWorldMatrix, KK,
                                                                         Kc)
        currentPoseAxesInImage = self._GetCalibrationBoardAxesInImage(cameracal, boardInWorldMatrix,
                                                                      sensorInWorldMatrix, KK, Kc)

        detectedPatternDotsInImage = None  # from detection
        detectedSensorInWorldMatrix = None  # from detection
        if runDetection:
            detectedPatternDotsInImage, detectedSensorInWorldMatrix = self._ComputeSensorPoseFromPatternDetection(
                cameracal, boardInWorldMatrix, intensityImageData, KK, Kc)
            log.debug(
                'Computed new camera pose now from sensorName "%s", sensorLinkName "%s", imageType "%s", detectedSensorInWorldMatrix=%r',
                intensityImage.GetSensorName(), intensityImage.GetSensorLinkName(), intensityImage.GetImageType(),
                detectedSensorInWorldMatrix)

        # have to convert to sensorLink coordinate system
        with self._managerGroup.clientPoolGroup.planningclientpool.CreateUseScope() as planningclient:
            planningclient.SetRobotName(self.GetRobotName())
            result = planningclient.GetTransform(sensorName, linkName=sensorLinkName)
            sensorLinkInWorldMatrix = eye(4)
            sensorLinkInWorldMatrix[:3, :3] = result['rotationmat']
            sensorLinkInWorldMatrix[:3, 3] = result['translation']

        singleShotCalibrationResultCache = {
            'sensorSelectionInfo': {'sensorName': intensityImage.GetSensorName(),
                                    'sensorLinkName': intensityImage.GetSensorLinkName()},
            'imageType': intensityImage.GetImageType(),
            'calibrationBoardPath': calibrationBoardPath,
            'currentSensorLinkInWorldMatrix': sensorLinkInWorldMatrix.tolist(),
        }

        detectedPoseAxesInImage = None
        detectedSensorLinkInWorldMatrix = None
        if runDetection and detectedSensorInWorldMatrix is not None:
            detectedPoseAxesInImage = self._GetCalibrationBoardAxesInImage(cameracal, boardInWorldMatrix,
                                                                           detectedSensorInWorldMatrix, KK, Kc)

            linkInSensorMatrix = dot(basicmath.InvertIsometricMatrix(sensorInWorldMatrix), sensorLinkInWorldMatrix)
            detectedSensorLinkInWorldMatrix = dot(detectedSensorInWorldMatrix, linkInSensorMatrix)

            # Cacheing new camera transform
            # rotabc = basicmath.zyxFromMatrix(detectedSensorLinkInWorldMatrix[:3, :3])
            # xyzabc = numpy.r_[detectedSensorLinkInWorldMatrix[:3, 3], numpy.rad2deg(rotabc)].tolist()
            singleShotCalibrationResultCache[
                'detectedSensorLinkInWorldMatrix'] = detectedSensorLinkInWorldMatrix.tolist()

        self._singleShotCalibrationResultCache = singleShotCalibrationResultCache
        return (
            intensityImage,
            detectedPatternDotsInImage,
            currentPatternDotsInImage,
            detectedPoseAxesInImage,
            currentPoseAxesInImage,
            detectedSensorLinkInWorldMatrix,
        )

    @OrchestratorCommandDecorator
    def ComputeSingleShotCalibrationWithLiveImage(self, *args, **kwargs):
        intensityImage, detectedPatternDotsInImage, currentPatternDotsInImage, detectedPoseAxesInImage, currentPoseAxesInImage, detectedSensorLinkInWorldMatrix = self._ComputeSingleShotCalibrationWithLiveImage(
            *args, **kwargs)
        return {
            "image": intensityImage.Serialize() if intensityImage is not None else None,
            "detectedPatternDots": numpy.array(
                detectedPatternDotsInImage).tolist() if detectedPatternDotsInImage is not None else None,
            "objectPointsInImage": currentPatternDotsInImage.tolist() if currentPatternDotsInImage is not None else None,
            "poseAxesInImage": detectedPoseAxesInImage.tolist() if detectedPoseAxesInImage is not None else None,
            "currentPoseAxesInImage": currentPoseAxesInImage.tolist() if currentPoseAxesInImage is not None else None,
            "cameraTransform": detectedSensorLinkInWorldMatrix.tolist() if detectedSensorLinkInWorldMatrix is not None else None
        }

    def _PackPlotImage(self, image=None):
        if image is None or not isinstance(image, numpy.ndarray):
            return None
        return {
            'type': image.dtype.str,
            'shape': image.shape,
            'data': image.data if image.flags['C_CONTIGUOUS'] else image.tobytes()
        }

    def GetRunStatus(self):
        if self._IsCalibrationRunning():
            return 'Working'

        if self._managerGroup.monitorGroup.robotBridgeMonitor.GetSystemControlMode() == 'Check':
            return 'Active'

        return 'Idle'

    def GetStatusMessage(self):
        statusMessage = self._stateManager.GetStatusMessage()
        cmanager = self._GetCalibrationManager()
        if cmanager is not None:
            statusMessage += '\n' + cmanager.GetStatus()
        return statusMessage

    def GetFinishState(self):
        self._stateManager.GetFinishState()

    def SpinOrchestratorOnce(self):
        super(CalibrationOrchestrator, self).SpinOrchestratorOnce()

    def _GetSystemStatus(self):
        return self._systemstatusandtimestamp

    def _SetSystemStatus(self, value):
        status, message = value
        old_status, old_message, _ = self._systemstatusandtimestamp or (None, None, None)
        if value != (old_status, old_message):
            if status != ComponentStatusCode.Communicating:
                log.warn(u'System health changed: %s' % message)
            else:
                log.info(u'System health changed: %s' % message)

        self._systemstatusandtimestamp = (status, message, time.time())

    _systemstatus = property(_GetSystemStatus, _SetSystemStatus)

    def GetSystemStatus(self):
        """returns the status of the entire system
        :return: (connected status, statusmsg)
            """
        return self._systemstatus

    def SetSystemStatus(self, systemstatus):
        self._systemstatus = systemstatus

    def GetPublishState(self):
        publishState = super(CalibrationOrchestrator, self).GetPublishState()

        publishState.update(self._stateManager.GetPublishState())

        return publishState
